% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clever.R
\name{clever}
\alias{clever}
\title{Identify outliers with \code{clever}}
\usage{
clever(
  X,
  projection = "PCA_kurt",
  out_meas = "leverage",
  DVARS = TRUE,
  detrend_PCs = TRUE,
  PCATF_kwargs = NULL,
  kurt_quantile = 0.95,
  kurt_detrend = TRUE,
  id_outliers = TRUE,
  lev_cutoff = 4,
  rbd_cutoff = 0.9999,
  R_true = NULL,
  lev_images = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{X}{Numerical data matrix. Should be wide (N observations x P variables, 
\eqn{N >> P}).}

\item{projection}{Character vector indicating the projection methods
to use. Choose at least one of the following: \code{"PCA_var"} for 
PCA + variance, \code{"PCA_kurt"} for PCA + kurtosis, and \code{"PCATF"} for
PCA Trend Filtering + variance. Or, use \code{"all"} to use all projection 
methods. Default: \code{c("PCA_kurt")}.}

\item{out_meas}{Character vector indicating the outlyingness measures to 
compute. Choose at least one of the following: \code{"leverage"} for 
leverage, or \code{"robdist"} for robust distance. Or, use \code{"all"} 
to use both methods. Default: \code{c("leverage")}.}

\item{DVARS}{Should DVARS (Afyouni and Nichols, 2017) be computed too? Default 
is \code{TRUE}.}

\item{detrend_PCs}{Detrend all PCs before computing leverage or robust 
 distance? Default: \code{TRUE}.

 Detrending is recommended for time-series data, especially if there are many
 time points or changing circumstances, such as in task-based fMRI. 
 Detrending should not be used with non-time-series data because the 
 observations are not temporally related.}

\item{PCATF_kwargs}{Named list of arguments for PCATF projection method.
 Only applies if \code{("PCATF" \%in\% projection)}.

 Valid entries are: 
 
 \describe{
   \item{K}{maximum number of PCs to compute (Default: \code{1000})}
   \item{lambda}{trend filtering parameter (Default: \code{0.05})}
   \item{niter_max}{maximum number of iterations (Default: \code{1000})}
   \item{verbose}{Print updates? (Default: \code{FALSE})}
 }}

\item{kurt_quantile}{What cutoff quantile for kurtosis should be used? Only 
applies if \code{("PCA_kurt" \%in\% projection)}. Default: \code{0.95}.}

\item{kurt_detrend}{Should the PCs be detrended before measuring kurtosis? 
 Only applies if \code{("PCA_kurt" \%in\% projection)}. Default: \code{TRUE}. 

 Detrending is highly recommended for time-series data, because trends can 
 induce high kurtosis even in the absence of outliers. Detrending should not
 be done with non-time-series data because the observations are not 
 temporally related.}

\item{id_outliers}{Should the outliers be identified? Default: \code{TRUE}.}

\item{lev_cutoff}{The outlier cutoff value for leverage, as a multiple of the
median leverage. Only used if 
\code{"leverage" \%in\% projection} and \code{id_outliers}. Default: 
\code{4}, or \eqn{4 * median}.}

\item{rbd_cutoff}{The outlier cutoff quantile for MCD distance. Only used if 
 \code{"robdist" \%in\% projection} and \code{id_outliers}. Default: 
 \code{0.9999}, for the \eqn{0.9999} quantile.

 The quantile is computed from the estimated F distribution.}

\item{R_true}{The N x N correlation matrix, if known. Used for the bootstrap
robust distance method.}

\item{lev_images}{Should leverage images be computed? If \code{FALSE} memory
is conserved. Default: \code{FALSE}.}

\item{verbose}{Should occasional updates be printed? Default: \code{FALSE}.}
}
\value{
A clever object, i.e. a list with components
\describe{
 \item{params}{A list of all the arguments used.}
 \item{projections}{
   \describe{
     \item{PC_var}{
       \describe{
         \item{indices}{The indices retained from the original SVD 
           projection to make the variance-based PC projection.} 
         \item{PCs}{The PC projection.}  
       }
     }
     \item{PC_kurt}{
       \describe{
         \item{indices}{The indices retained from the original SVD 
           projection to make the kurtosis-based PC projection. They are 
           ordered from highest kurtosis to lowest kurtosis.}  
         \item{PCs}{The PC projection. PCs are ordered in the standard
           way, from highest variance to lowest variance, instead of by 
           kurtosis.}  
       }
     }
     \item{PCATF}{
       \describe{
         \item{indices}{The indices of the trend-filtered PCs used to make the
           projection.}  
         \item{PCs}{The PCATF result.}  
       }
     }
   }
 }
 \item{outlier_measures}{
   \describe{
     \item{PC_var__lev}{The leverage values for the PC_var projection.}
     \item{PC_kurt__lev}{The leverage values for the PC_kurt projection.}
     \item{PCATF__lev}{The leverage values for the PCATF projection.}
     \item{PC_var__rbd}{The robust MCD distance values for the PC_var projection.}
     \item{PC_kurt__rbd}{The robust MCD distance values for the PC_kurt projection.}
     \item{DVARS_DPD}{The Delta percent DVARS values.}
     \item{DVARS_ZD}{The DVARS z-scores.}
   }
 }
 \item{outlier_cutoffs}{
   \describe{
     \item{lev}{The leverage cutoff for outlier detection: \code{lev_cutoff} times
       the median leverage.}
     \item{MCD}{The robust distance cutoff for outlier detection: the 
       \code{rbd_cutoff} quantile of the estimated F distribution.}
     \item{DVARS_DPD}{The Delta percent DVARS cutoff: +/- 5 percent}
     \item{DVARS_ZD}{The DVARS z-score cutoff: the one-sided 5 percent 
       significance level with Bonferroni FWER correction.}
   }
 }
 \item{outlier_flags}{
   \describe{
     \item{PC_var__leverage}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
     \item{PC_kurt__leverage}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
     \item{PCATF__leverage}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
     \item{PC_var__robdist}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
     \item{PC_kurt__robdist}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
     \item{DVARS_DPD}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
     \item{DVARS_ZD}{Logical vector idnicating whether each observation surpasses the outlier cutoff.}
   }
 }
 \item{robdist_info}{
   \describe{
     \item{PC_var__robdist}{
       \describe{
         \item{inMCD}{Logical vector indicating whether each observation was in the MCD estimate.}
         \item{outMCD_scale}{The scale for out-of-MCD observations.}
         \item{Fparam}{Named numeric vector: c, m, df1, and df2.}
       }
     }
     \item{PC_var__robdist}{
       \describe{
         \item{inMCD}{Logical vector indicating whether each observation was in the MCD estimate.}
         \item{outMCD_scale}{The scale for out-of-MCD observations.}
         \item{Fparam}{Named numeric vector: c, m, df1, and df2.}
       }
     }
   }
 }
 \item{MCD_scale}{The scale value for out-of-MCD observations, and NA for
   in-MCD observations. NULL if \code{method} is not robust distance.}
 \item{lev_images}{
   \describe{
     \item{mean}{The average of the PC directions, weighted by the unscaled
       PC scores at each outlying time point (U[i,] * V^T). Row names are
       the corresponding time points.}
     \item{top}{The PC direction with the highest PC score at each outlying
       time point. Row names are the corresponding time points.}
     \item{top_dir}{The index of the PC direction with the highest PC score
       at each outlying time point. Named by timepoint.}
   }
 }
}
}
\description{
Calculates PCA leverage or robust distance and identifies outliers.
}
\details{
\code{clever} will use all combinations of the requested projection and 
 out_meas methods that make sense. For example, if  
 \code{projection=c("PCATF", "PCA_var", "PCA_kurt")} and 
 \code{out_meas=c("leverage", "robdist")} then these five
 combinations will be used: PCATF with leverage, PCA + variance with 
 leverage, PCA + variance with robust distance, PCA + kurtosis with leverage,
 and PCA + kurtosis with robust distance. Each method combination will yield 
 its own out_meas time series.
}
\examples{
n_voxels = 1e4
n_timepoints = 100
X = matrix(rnorm(n_timepoints*n_voxels), ncol = n_voxels)

clev = clever(X)
}
