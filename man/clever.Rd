% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clever.R
\name{clever}
\alias{clever}
\title{Identify outliers with \code{clever}}
\usage{
clever(
  X,
  measures = c("leverage", "DVARS"),
  ROI_data = c(NA, NaN),
  ROI_noise = NULL,
  X_motion = NULL,
  projections = "PCA_kurt",
  compute_PC_dirs = FALSE,
  detrend = TRUE,
  noise_nPC = 5,
  noise_erosion = NULL,
  PCATF_kwargs = NULL,
  kurt_quantile = 0.95,
  get_outliers = TRUE,
  outlier_cutoffs = list(leverage = 4, robdist = 0.9999, DVARS = "Afyouni_Nichols", FD
    = 0.5),
  verbose = FALSE
)
}
\arguments{
\item{X}{Wide numerical data matrix (\eqn{T observations \times V variables}, \eqn{T << V}).
 For example, if \code{X} represents an fMRI run, \eqn{T} should be the number
 of timepoints and \eqn{V} should be the number of brainordinate vertices/voxels.

 Or, a 4D array or NIFTI or file path to a NIFTI (\eqn{I \times J \times K \times T} 
 observations), in which case \code{ROI_data} must be provided.

 Or, a \code{ciftiTools} code{"xifti"} object or a file path to a CIFTI
 (\eqn{V_{left} + V_{right} + V_{subcortical} \times T observations}).}

\item{measures}{Character vector indicating the outlyingness measures to 
 compute. Choose at least one of the following: 

 \describe{
   \item{\code{"leverage"}}{PCA leverage (the mean of the squared PC scores)}
   \item{\code{"robdist"}}{Robust Mahalanobis-based distance}
   \item{\code{"CompCor"}}{anatomical CompCor based on the ROIs. \code{X} must
     be a 4D array or NIFTI, and \code{ROI_data} and \code{ROI_noise} are required.}
   \item{\code{"DVARS"}}{traditional-DVARS, as well as Delta-percent-DVARS and
     z-score-DVARS (Afyouni and Nichols, 2018)}
   \item{\code{"FD"}}{Framewise Displacement. \code{X_motion} is required.}
 }

 Use \code{"all"} to select all outlyingness measures. Default: \code{"leverage", "DVARS"}.}

\item{ROI_data}{Indicates the data ROI. 

 If \code{X} is a matrix, this must be a length \eqn{V} logical vector, where
 the data ROI is indicated by \code{TRUE} values. If not provided, all 
 columns of \code{X} will be included in the data ROI (all \code{TRUE}).

 If \code{X} is an array or NIFTI, this must be either a vector of values
 to expect for out-of-mask voxels in \code{X}, or a (file path to a) 3D NIFTI.
 In the latter case, each of the volume dimensions should match the first
 three dimension of \code{X}. Voxels in the data ROI should be indicated by
 \code{TRUE} and all other voxels by \code{FALSE}. If not provided,
 will be set to \code{c(0, NA, NaN)} (include all voxels which are not constant
 \code{0}, \code{NA}, or \code{NaN}).

 If \code{X} is a \code{"xifti"} this should not be used. All data locations
 will be used.}

\item{ROI_noise}{Indicates the noise ROI. Only used if the \code{"CompCor"} 
 measure is requested.
 
 If \code{X} is a matrix, this must be a list of length \eqn{V} logical
 vectors, or a list of matrices with \code{T} rows. The names of each entry should
 indicate the name of the noise ROI, e.g. \code{"white_matter"} and \code{"csf"}.
 In the first case, \code{TRUE} values should indicate the locations of \code{X} 
 within that noise ROI. Since the ROIs must not overlap, the masks must be 
 mutually exclusive with each other, and with \code{ROI_data}. In the second
 case, the rows of the matrix must represent noise brainordinate timecourses,
 separate from \code{X}. 

 If \code{X} is an array or NIFTI, this must be a list of (file paths to) 3D 
 NIFTIs or arrays, or a list of matrices with \code{T} rows. The names of 
 each entry should indicate the name of the noise ROI, e.g. 
 \code{"white_matter"} and \code{"csf"}. In the first case, each of the volume 
 dimensions should match the first three dimensions of \code{X}. Voxels in 
 each noise ROI should be indicated by \code{TRUE} and all other voxels by 
 \code{FALSE}. Since the ROIs must not overlap, the masks must be mutually 
 exclusive with each other, and with \code{ROI_data}. In the second case,
 the rows of the matrix must represent noise brainordinate timecourses,
 separate from \code{X}. 

 If \code{X} is a \code{"xifti"}, this must be a list of matrices with 
 \code{T} rows. The names of each entry should indicate the name of the noise
 ROI, e.g. \code{"white_matter"} and \code{"csf"}. The rows of the matrix 
 must represent noise brainordinate timecourses, separate from \code{X}.}

\item{X_motion}{Only used if the \code{"FD"} measure is requested. An 
\eqn{N \times 6} matrix in which the first three columns represent the
translational realignment parameters (mm), and the second three columns represent
the rotational realignment parameters in (radians). To convert radians to mm,
the displacement on a sphere of radius 50 mm will be computed.}

\item{projections}{Only applies to the \code{"leverage"} and \code{"robdist"} 
 measures. These work by projecting the data onto directions likely to 
 contain outlier information. Choose at least one of the following:

 \describe{
   \item{\code{"PCA_var"}}{PCA using the PCs of above-average variance. Compatible with both leverage and robust distance.}
   \item{\code{"PCA_kurt"}}{PCA using the PCs of high kurtosis and above-average variance. Compatible with both leverage and robust distance.}
   \item{\code{"PCATF"}}{PCATF using the trend-filtered PCs of above-average variance. Compatible with only leverage.}
 }
 
 Use \code{"all"} to use all projection methods. Default: \code{"PCA_kurt"}.
 
 Each compatible measure + projection combination will yield its own result.
 For example, if all projections are used and both leverage and robust distance
 are requested, the results will be: leverage of high-variance PCs, leverage
 of high-kurtosis PCs, leverage of trend-filtered PCs, robust distance of
 high-variance PCs, and robust distance of high-kurtosis PCs.}

\item{compute_PC_dirs}{Only applies to the \code{"leverage"} and \code{"robdist"} 
measures. Should the PCA and PCATF principal directions be computed? 
Default: \code{FALSE} (conserves memory). Required to use \code{\link{leverage_images}}.}

\item{detrend}{Only applies to the \code{"leverage"} and \code{"robdist"} 
 measures. Detrend the PCs before measuring kurtosis and before measuring
 leverage or robust distance? Default: \code{TRUE}.

 Detrending is highly recommended for time-series data, especially if there 
 are many time points or evolving circumstances affecting the data. Additionally,
 for the kurtosis-based projection, trends can induce positive or negative kurtosis,
 contaminating the connection between high kurtosis and outlier presence. 
 
 Detrending should not be used with non-time-series data because the 
 observations are not temporally related.

 In addition to \code{TRUE} and \code{FALSE}, a third option \code{"kurtosis"}
 can be used to only detrend the PCs for the purpose of measuring kurtosis, 
 and not for the actual outlyingness measurement.

 This option will not affect the PCATF PCs, which are never detrended.}

\item{noise_nPC}{Only applies to the \code{"CompCor"} measure. The number of 
principal components to compute for each noise ROI. Should be a list or numeric
vector with the same length as \code{ROI_noise}. It will be matched to each
ROI based on the name of each entry, or if the names do not match or are missing,
the order of entries. If it is an unnamed vector, its elements will be recycled.
Default: \code{5} (compute the top 5 PCs for each noise ROI).}

\item{noise_erosion}{Only applies to the \code{"CompCor"} measure. The number
of voxel layers to erode the noise ROIs by. Should be a list or numeric
vector with the same length as \code{ROI_noise}. It will be matched to each
ROI based on the name of each entry, or if the names do not match or are missing,
the order of entries. If it is an unnamed vector, its elements will be recycled.
Default: \code{NULL}, which will use a value of 0 (do not erode the noise ROIs).}

\item{PCATF_kwargs}{Options for the \code{"PCATF"} projection. Valid entries 
are: 

\describe{
  \item{K}{Maximum number of PCs to compute. Default: \code{100}. Cannot be set above 100.}
  \item{lambda}{Trend-filtering parameter. Default: \code{0.05}.}
  \item{niter_max}{Maximum number of iterations. Default: \code{1000}.}
  \item{verbose}{Print updates? Default: \code{FALSE}.}
}}

\item{kurt_quantile}{Only applies to \code{"PCA_kurt"} projection. 
What cutoff quantile for kurtosis should be used to select the PCs? 
Default: \code{0.95}.}

\item{get_outliers}{Should outliers be flagged based on cutoffs? Default: \code{TRUE}.}

\item{outlier_cutoffs}{Named list indicating the cutoff for each outlyingness measure.
 Only used if \code{get_outliers}. Each cutoff is specified in a particular way:

 \describe{
   \item{\code{"leverage"}}{Minimum leverage value, in multiples of the median leverage. Default: \code{4} (will flag leverage scores more than four times the median).}
   \item{\code{"robdist"}}{Minimum robust distance quantile, based on the estimated F distribution. Default: \code{.9999} (will flag robust distance scores above the 99.99th percentile).}
   \item{\code{"CompCor"}}{Not applicable: not used for outlier detection. Should not be specified.}
   \item{\code{"DVARS"}}{Minimum traditional-DVARS value, or "Afyouni_Nichols" (default), in which case
     their dual cutoff will be used (Delta-percent-DVARS of more than +5\% or 
     less than -5\% AND z-score=DVARS greater than the right-tail
     5\% significance level with Bonferroni FWER correction).}
   \item{\code{"FD"}}{Minimum FD. Default: 0.5 mm (will flag FD scores greater than 0.5 mm).}
 }}

\item{verbose}{Should occasional updates be printed? Default: \code{FALSE}.}
}
\value{
A \code{"clever"} object, i.e. a list with components
\describe{
 \item{measures}{
   A list of the outlyingness measures (only those requested will be included):
   \describe{
     \item{leverage__PCA_var}{Leverage values of the "PCA_var" projection.}
     \item{leverage__PCA_kurt}{Leverage values of the "PCA_kurt" projection.}
     \item{leverage__PCATF}{Leverage values of the "PCATF" projection.}
     \item{robdist__PCA_var}{Robust distance values of the "PCA_var" projection.}
     \item{robdist__PCA_kurt}{Robust distance values of the "PCA_kurt" projection.}
     \item{CompCor_[Noise1]_PC1}{First PC of the first noise ROI.}
     \item{...}{...}
     \item{CompCor_[Noisek]_PCn}{nth PC of the kth (last) noise ROI.}
     \item{DVARS}{Traditional DVARS values.}
     \item{DVARS_DPD}{Delta-percent-DVARS values.}
     \item{DVARS_ZD}{z-score-DVARS values.}
     \item{FD}{Framewise Displacement values}
   }
 }
 \item{outlier_cutoffs}{
   A list of the outlier cutoffs for each measure (see the \code{outlier_cutoffs}
   argument; only those requested will be included):
   \describe{
     \item{leverage__PCA_var}{Minimum leverage.}
     \item{leverage__PCA_kurt}{Minimum leverage.}
     \item{leverage__PCATF}{Minimum leverage.}
     \item{robdist__PCA_var}{Minimum robust distance.}
     \item{robdist__PCA_kurt}{Minimum robust distance.}
     \item{DVARS}{Minimum DVARS.}
     \item{DVARS_DPD}{Minimum absolute value of the Delta-percent-DVARS.}
     \item{DVARS_ZD}{Minimum z-score-DVARS.}
     \item{FD}{Minimum Framewise Displacement.}
   }
 }
 \item{outlier_flags}{
   Applies \code{outlier_cutoffs} to \code{measures}: each is a logical vector
   with \code{TRUE} values indicating suspected outlier presence. 
 }
 \item{ROIs}{
   \describe{
     \item{data}{The mask of locations in the data ROI.}
     \item{[Noise1]}{The mask of locations in the first noise ROI, if it was relative to \code{X}.}
     \item{...}{...}
     \item{[Noisek]}{The mask of locations in the kth (last) noise ROI, if it was relative to \code{X}.}
   }
 }
 \item{PCA}{
   If the "PCA_var" or "PCA_kurt" projections were used, this will be a list with components:
   \describe{
     \item{U}{The \eqn{N x Q} PC score matrix. Only PCs with above-average variance will be included.}
     \item{U_dt}{The \eqn{N x Q} detrended PC score matrix. Included only if \code{detrend}}
     \item{D}{The variance of each PC. Only PCs with above-average variance will be included.}
     \item{V}{The \eqn{P x Q} PC directions matrix. Included only if \code{!compute_PC_dirs}}
     \item{kurt_idx}{The length \code{Q} kurtosis rankings, with 1 indicating the highest-kurtosis PC 
       (among those of above-average variance) and \code{NA} indicating a PC with kurtosis below
       the quantile cutoff. Only included if the "PCA_kurt" projection was used.}
   }
 }
 \item{PCATF}{
   If the "PCATF" projection was used, this will be a list with components:
   \describe{
     \item{U}{The \eqn{N x Q} PC score matrix. Only PCs with above-average variance will be included.}
     \item{D}{The variance of each PC. Only PCs with above-average variance will be included.}
     \item{V}{The \eqn{P x Q} PC directions matrix. Included only if \code{!compute_PC_dirs}}
   }
 }
 \item{robdist}{
   If the "robdist" method was used, this will be a list with components:
   \describe{
     \item{PCA_var}{
     If the "PCA_var" projection was used, this will be a list with components:
       \describe{
         \item{inMCD}{Logical vector indicating whether each observation was in the MCD estimate.}
         \item{outMCD_scale}{The scale for out-of-MCD observations.}
         \item{Fparam}{Named numeric vector: \code{c}, \code{m}, \code{df1}, and \code{df2}.}
       }
     }
     \item{PCA_kurt}{
     If the "PCA_kurt" projection was used, this will be a list with components:
       \describe{
         \item{inMCD}{Logical vector indicating whether each observation was in the MCD estimate.}
         \item{outMCD_scale}{The scale for out-of-MCD observations.}
         \item{Fparam}{Named numeric vector: \code{c}, \code{m}, \code{df1}, and \code{df2}.}
       }
     }
   }
 }
}
}
\description{
Calculates PCA leverage or robust distance and identifies outliers.
}
\details{
\code{clever} will use all combinations of the requested projections and 
 outlyingness measures which make sense. For example, if  
 \code{projection=c("PCATF", "PCA_var", "PCA_kurt")} and 
 \code{out_meas=c("leverage", "robdist")} then these five
 combinations will be used: PCATF with leverage, PCA + variance with 
 leverage, PCA + variance with robust distance, PCA + kurtosis with leverage,
 and PCA + kurtosis with robust distance. Each method combination will yield 
 its own results.

Each voxel timecourse is centered on its median and scaled by 1.4826 times
 the median of the absolute values (a robust measure of standard deviation).
 This differs from the centering method of DVARS (Afyouni and Nichols, 2018),
 so results may differ.
}
\examples{
n_voxels = 1e4
n_timepoints = 100
X = matrix(rnorm(n_timepoints*n_voxels), ncol = n_voxels)

clev = clever(X)
}
